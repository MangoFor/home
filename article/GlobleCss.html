<h2>全局css的尽头</h2>
<p>Css选择器都存在于同一个全局环境中</p>
<p>任何有年头的css使用者都不得不忍受它极具侵略性的全局特性，这是一个在documents的年代就诞生的模型，而我们现在却努力地为现代的web应用提供一个更加温顺的工作环境</p>
<p>每一个选择器都有可能产生意料之外的影响，因为每一个选择器都有可能选择了其它元素或和其它选择器冲突。更有甚者，我们的选择器可能会在全局作用域生死决斗中被干掉，最终产生一点或根本对页面没有产生影响。</p>
    <p>我们每次修改css文件的时候，都要小心谨慎地考虑样式所在的全局环境，并没有其它前端技术仅仅是为了这一丁点的代码可维护性，而去遵守这么多的规则。</p>
    <p>然而我们并不需要这样</p>
    <p>是时候干掉全局样式了</p>
    <blockquote>
        <p>在其它语言，有时稍微改改全局变量时可以接受的，如果有过的话~</p>
    </blockquote>
    <p>在JavaScript社区，幸亏有像Browserify，webpack和JSPM之类的框架，我们可以让我们的代码包含很多小模块，每一个模块分装好各自的依赖项，只暴露出最少的API</p>
    <p>然而，CSS却可以随时作用于任何模块</p>
    <p>很多人，也包括我自己，到目前为止已经使用CSS太久了，以致我们没有觉得局部作用域的缺失是一个可以不需要浏览器厂商放大招就可以解决的问题。即使这样，我们仍需要去等待大部分用户都使用支持影子树(目前只有高版本chrome支持)的浏览器</p>
    <p>我们至今都使用着，像OOCSS,SMACC,BEM和SUIT之类的命名规则和全局CSS的问题作斗争，它们提供为了我们提供了避免命名冲突和模拟正常命名空间规则的方法。</p>
    <p>不可否认的是，在改良CSS的道路还很遥远，并没有什么方法能够真正解决样式表的问题，不管我们选择哪一种约定，我们都会被全局选择器卡住。</p>
    <p>但在2015年4月22日，一切都变了</p>
    <p>正如我们前一篇文章——“Block，Element，Modifying Your JavaScript  Components”所说的——我们能够利用Webpack在js模块中引入CSS文件。如果你对此不太熟悉，可以看看这篇文章，以免漏掉重要的内容</p>
    <p>用Webpack的css-loader引入组件的CSS代码如下</p>
<pre><code>require('./MyComponent.css');
</code></pre>

    <p>第一眼看，甚至以为我们引入的不是CSS而是JS，这的确很奇怪</p>
    <p>一般来说，调用一个require应该给局部的作用域引入东西，如果没有，正如前面影响全局全局作用域所介绍的，这是一个二流设计的表现</p>
    <p>但这是CSS，影响全局作用域是必要的恶行</p>
    <p>我们也许会这么认为</p>
    <p>在2015年4月22号，Tobias Kopper，这位Webpack的作者提交了css-loader新特性的第一个迭代版本，那时被叫做placeholders，也就是局部作用域。	</p>
    <p>这个特性允许我们从CSS文件输出类名输出到JavaScript代码中</p>
    <p>总之，原来的写法：</p>
<pre><code>require('./MyComponent.css');
</code></pre>

    <p>现在：</p>
<pre><code>import styles from './MyComponent.css';
</code></pre>

    <p>所以，在这个例子中，样式被编译为什么？</p>
    <p>注意从CSS中到底有什么被导出，我们看一下样式表大致的形式是：</p>
<pre><code>:local(.foo) {
    color: red;
}
:local(.bar) {
    color: blue;
}
</code></pre>

    <p>在这个例子里面，我们使用css-loader的定义：loacl(.identifier)语法来输出两个标识符——foo和bar</p>
    <p>这些标识符映射着我们在JavaScript文件中用到的类名，例如在使用React时：</p>
<pre><code>import styles from './MyComponent.css';
    import React, { Component } from 'react';
    export default class MyComponent extends Component {
        render() {
        return (
        &lt;div&gt;
        &lt;div className={styles.foo}&gt;Foo&lt;/div&gt;
        &lt;div className={styles.bar}&gt;Bar&lt;/div&gt;
        &lt;/div&gt;
        );
    }
}
</code></pre>

    <p>重要的是，这些标识符映射的类名在全局作用域中一定是独一无二的。</p>
    <p>我们再也不需要给所有选择器添加冗长的前缀去模拟作用域了。更多的组件定义他们自己的foo和bar标识符了，不像传统的全局选择器模型，无法减少命名冲突</p>
    <p>了解这其中发生的巨大变化非常重要</p>
    <p>我们现在能够大胆地改变我们的CSS代码，而不用担心无意间影响到页面上的其它元素，我们为CSS引用了一种更为健全的的作用域模型</p>
    <p>全局CSS的好处就是样式在于，不同组件间能通过通用类名的实现可重用性，然而这在新模型中也可以实现，关键的区别在于，就像我们使用别的技术，我们需要明确地引入依赖的类，我们的代码不能够有很多关于全局环境的设想.</p>
    <blockquote>
        <p>现在我们鼓励编写可维护的CSS代码，但不是通过对命名规范的坚守，而是在开发过程中封装样式。</p>
    </blockquote>
    <p>作为使用了这种作用域的代价，我们把对类名的实际控制交给了给了Webpack</p>
    <p>css-loader会默认把我们的标识符转化为哈希值</p>
    <p>例如：</p>
<pre><code>:local(.foo) { … }
</code></pre>

    <p>被编译为：</p>
<pre><code>._1rJwx92-gmbvaLiDdzgXiJ { … }
</code></pre>

    <p>在开发中，这对调式来说并不是特别有帮助，为了让类名更加好用，我们可以在Webpack的配置文件中配置类名的格式，并作为一个参数传给css-loader：</p>
<pre><code>loaders: [
    ...
    {
        test: /\.css$/,
        loader: 'css?localIdentName=[name]__[local]___[hash:base64:5]'
    }
]
</code></pre>

    <p>这样一来，我们foo标识符会从原先被编译为这样：</p>
<pre><code>.MyComponent__foo___1rJwx { … }
</code></pre>

    <p>我们现在就能清晰地看出标识符的名称，还有组件的归属</p>
    <p>通过使用node_nev环境变量，我们能够为开发和生产环境配置不同的类名</p>
<pre><code>loader: 'css?localIdentName=' + (
    process.env.NODE_ENV === 'development' ?
    '[name]__[local]___[hash:base64:5]' :
    '[hash:base64:5]'
)
</code></pre>

    <blockquote>
        <p>既然Webpack已经控制了我们的类名，那我们就能在线上环境中支持压缩类名。</p>
    </blockquote>
    <p>当我们一发现这些特性，我们会毫不犹豫地在最近的项目中本地化我们的样式，而如果我们已经在每一个组件中使用BEM本地化我们的CSS，只要按照规范，这会是一个自然而然的过程</p>
    <p>有趣的是，一个模式就这样快速地产生了，我们大多数的CSS文件只会包含了本地的标识符</p>
<pre><code>:local(.backdrop) { … }
:local(.root_isCollapsed .backdrop) { … }
:local(.field) { … }
:local(.field):focus { … }
etc…
</code></pre>

    <p>全局选择器只有在应用中的少数地方被用到，这自然而然地引向了一个问题。</p>
    <blockquote>
        <p>如果替代掉那之前的local语法，我们的选择默认就是本地的，而全局选择器只是一个可选项
            如果我们改了之后会怎样？</p>
    </blockquote>
<pre><code>.backdrop { … }
.root_isCollapsed .backdrop { … }
.field { … }
.field:focus { … }
</code></pre>

    <p>因为这些选择会自然地变得太模糊，把它们转化为css-loader的本地作用域格式会消除这些问题，并且保证它们只会在被使用到的模块中</p>
    <p>当不得不使用全局样式时，我们能够明确地使用全局语法做记号</p>
    <p>例如，当使用ReactCSSTransitionGroup生成的非局部样式类时</p>
<pre><code>.panel :global .transition-active-enter { … }
</code></pre>

    <p>在这里我们不仅用了本地作用域的panel标识符，还使用了在我们控制之外的全局的类名。</p>
    <p>一旦我们开始研究如何使用默认本地的语法，我们会意识到这并不会太难。</p>
    <p>为了这个目的，我们可以利用PostCSS，一个可以让我们编写CSS转换插件的神奇的工具，其中最有名的CSS构建工具是Autoprfixer，实际上是PostCSS的插件，同时也是一个独立的工具。</p>
    <p>令人兴奋的是，介绍局部作用的CSS只是一个开始。</p>
    <p>让构建工具处理类名的生成有很多潜在的巨大影响，从长远看，我们会不再做人肉编译器，而是让直接电脑最优化输出。</p>
    <blockquote>
        <p>未来，我们可以自动生成在不同的组件间共享的类，在编译阶段就根据样式的可重用性执行最优方案。</p>
    </blockquote>
    <p>一旦你使用过局部CSS，就真的回不了头。在样式表中体验真正的局部作用域，并且兼容所有浏览器，真是一件不可轻视的事。</p>
    <p>提出局部作用域对我们怎样处理CSS有着重大的连锁反应。命名规则，可重用模式，把样式取出放进单独的包中都深受这变化的直接影响。当然，我们只是站在局部CSS的这一新领域的山脚下</p>
    <p>我们现在仍着力于梳理这一转变的分支。通过大家有意义的输入和试验，我希望这是一个能让我们在一起组成一个更大的社区的对话。</p>
    <hr />
    <p>附上英文地址：<a href="https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284">https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284</a></p>
    <p>css-Load的地址：<a href="https://github.com/webpack/css-loader">https://github.com/webpack/css-loader</a></p>
<div id="disqus_thread"></div>