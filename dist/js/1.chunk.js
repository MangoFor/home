webpackJsonp([1],{

/***/ 363:
/***/ function(module, exports, __webpack_require__) {

	var map = {
		"./ExpressSourseCode.html": 364,
		"./GlobleCss.html": 365,
		"./index": 362,
		"./index.js": 362
	};
	function webpackContext(req) {
		return __webpack_require__(webpackContextResolve(req));
	};
	function webpackContextResolve(req) {
		return map[req] || (function() { throw new Error("Cannot find module '" + req + "'.") }());
	};
	webpackContext.keys = function webpackContextKeys() {
		return Object.keys(map);
	};
	webpackContext.resolve = webpackContextResolve;
	module.exports = webpackContext;
	webpackContext.id = 363;


/***/ },

/***/ 364:
/***/ function(module, exports, __webpack_require__) {

	module.exports = "<div class=\"container\"><h2 id=\"express深入解剖\">Express深入解剖</h2>\r\n\r\n    <hr>\r\n\r\n    <p>因为最近使用express时明显感觉很多使用细节还是性能优化方面，文档都没有很好的回答到，所以决定翻一翻源码</p>\r\n\r\n    <p>express的核心特性就是实现路由系统，实现对各路径的业务代码解耦。</p>\r\n\r\n    <p>Express的功能大致如下 <br>\r\n        1.  路由解析 <br>\r\n        2.  给request和response添加功能更强大的方法 <br>\r\n        3.  模板引擎</p>\r\n\r\n    <hr>\r\n\r\n\r\n\r\n    <h4 id=\"一-路由解析\">一.  路由解析</h4>\r\n\r\n    <p>原本的野生nodejs http请求可能会如下</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \"><span class=\"hljs-keyword\">var</span> http = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'http'</span>);\r\n    <span class=\"hljs-keyword\">var</span> server=http.createServer(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(req,res)</span>{</span>\r\n    <span class=\"hljs-keyword\">if</span>(req.url == <span class=\"hljs-string\">'/'</span>){\r\n    res.end(<span class=\"hljs-string\">'&lt;h1&gt;index&lt;/h1&gt;'</span>);\r\n    }\r\n    <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(req.url == <span class=\"hljs-string\">'/user'</span>){\r\n    res.end(<span class=\"hljs-string\">'&lt;h1&gt;user&lt;/h1&gt;'</span>);\r\n    }<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span>(req.url == <span class=\"hljs-string\">'info'</span>){\r\n    res.end(<span class=\"hljs-string\">'&lt;h1&gt;info&lt;/h1&gt;'</span>);\r\n    }\r\n    });\r\n    server.listen(<span class=\"hljs-number\">8000</span>);</code></pre>\r\n\r\n    <p>只有一个简陋的回调函数及其req,res，难道真的要用if else去判断所有的url，把所有的业务逻辑全写在里面？</p>\r\n\r\n    <p>并不是，我相信各位会有更好的解决方案。</p>\r\n\r\n    <p>而express也给出了一个不错的解决方案 <br>\r\n        代码大概如下</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \"><span class=\"hljs-keyword\">var</span> home = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'./routes/home);\r\n\r\napp.use('</span>/user<span class=\"hljs-string\">', function(req,res,next){\r\n    .....\r\n});\r\napp.use('</span>/info, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(req,res,next)</span>{</span>\r\n    .....\r\n    });\r\n    app.use(<span class=\"hljs-string\">'/home, home);\r\n\r\n// catch 404 and forward to error handler\r\napp.use(function(req, res, next) {\r\n    var err = new Error('</span>Not Found<span class=\"hljs-string\">');\r\n    err.status = 404;\r\n    next(err);\r\n});</span></code></pre>\r\n\r\n    <p><strong>./router/home</strong></p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \"><span class=\"hljs-keyword\">var</span> express = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">'express'</span>);\r\n    <span class=\"hljs-keyword\">var</span> router = express.Router();\r\n\r\n    <span class=\"hljs-comment\">/* GET home page. */</span>\r\n    router.get(<span class=\"hljs-string\">'/info'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(req, res)</span> {</span>\r\n    res.render(‘info’, { title: <span class=\"hljs-string\">'Express'</span> });\r\n    });\r\n    router.get(<span class=\"hljs-string\">'/info'</span>, <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(req, res)</span> {</span>\r\n    res.render(‘bar’, { title: <span class=\"hljs-string\">'Express'</span> });\r\n    });\r\n    module.exports = router;</code></pre>\r\n\r\n    <p>就像代码所示，express可以通过use，或get之类的方法把不同的请求路径本开处理 <br>\r\n        而整个过程就像一个流水线一样，除非匹配路径返回请求，否则一直走下去，直至最后的错误处理。</p>\r\n\r\n    <p>流程大概如图 <br>\r\n        <img src=\"http://img3.imgtn.bdimg.com/it/u=3766452328,271044185&amp;fm=21&amp;gp=0.jpg\" alt=\"enter image description here\" title=\"\"></p>\r\n\r\n    <p>源码解析 <br>\r\n        Express内部，router被封装成了一个对象，他的本质就是在内部使用一个stack数组来存储每一个Layer对象，通过了数组顺序遍历来匹配路径（怎么是这么low的方法，无语了。。）</p>\r\n\r\n    <p>Stack存放的是layer对象，layer封装了处理函数，匹配的路径，还有各种参数。</p>\r\n\r\n    <p>每一个express对象都会在内部new出一个router对象 <br>\r\n        代码如下</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \"><span class=\"hljs-keyword\">this</span>._router = <span class=\"hljs-keyword\">new</span> Router({\r\n    caseSensitive: <span class=\"hljs-keyword\">this</span>.enabled(<span class=\"hljs-string\">'case sensitive routing'</span>),\r\n    strict: <span class=\"hljs-keyword\">this</span>.enabled(<span class=\"hljs-string\">'strict routing'</span>)\r\n    });</code></pre>\r\n\r\n    <p>Router对象  <br>\r\n        这是它的构造函数(简化)</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \"><span class=\"hljs-keyword\">var</span> proto = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(options)</span> {</span>\r\n    options = options || {};\r\n\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">router</span><span class=\"hljs-params\">(req, res, next)</span> {</span>\r\n    router.handle(req, res, next);\r\n    }\r\n\r\n    router.__proto__ = proto;\r\n    router.stack = [];    <span class=\"hljs-comment\">//用于存放 每一个layer的数组</span>\r\n\r\n    <span class=\"hljs-keyword\">return</span> router;\r\n    };</code></pre>\r\n\r\n    <p>Layer构造函数</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \"><span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">Layer</span><span class=\"hljs-params\">(path, options, fn)</span> {</span>\r\n    options = options || {};\r\n\r\n    <span class=\"hljs-keyword\">this</span>.handle = fn;\r\n    <span class=\"hljs-keyword\">this</span>.regexp = pathRegexp(path, <span class=\"hljs-keyword\">this</span>.keys = [], options);\r\n    }</code></pre>\r\n\r\n    <p>它把path用pathRegexp转化为一个正则表达式，用于匹配每一个到来的请求。handle则是存放处理函数</p>\r\n\r\n    <p>router的use方法(简化)</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \">proto.use = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">use</span><span class=\"hljs-params\">(fn)</span> {</span>\r\n\r\n    ······\r\n\r\n    <span class=\"hljs-comment\">//callback存放着所有的回调函数</span>\r\n    callbacks.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(fn)</span> {</span>\r\n    <span class=\"hljs-keyword\">var</span> layer = <span class=\"hljs-keyword\">new</span> Layer(path, {\r\n    sensitive: self.caseSensitive,\r\n    strict: <span class=\"hljs-literal\">false</span>,\r\n    end: <span class=\"hljs-literal\">false</span>\r\n    }, fn);\r\n\r\n    layer.route = <span class=\"hljs-literal\">undefined</span>;\r\n    self.stack.push(layer);\r\n    });\r\n\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\r\n    };</code></pre>\r\n\r\n    <p>该方法用于给stack中添加layer对象，</p>\r\n\r\n    <p>Handle方法（简化）</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \">proto.handle = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(req, res, done)</span> {</span>\r\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\r\n\r\n    <span class=\"hljs-keyword\">var</span> stack = self.stack;\r\n    <span class=\"hljs-keyword\">var</span> idx=<span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-comment\">//递归函数，只有调用了next之后才能进入下一个路由</span>\r\n    next();\r\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">next</span><span class=\"hljs-params\">(err)</span> {</span>\r\n    <span class=\"hljs-keyword\">var</span> layerError = err;\r\n    <span class=\"hljs-comment\">//取出一个layer</span>\r\n    <span class=\"hljs-keyword\">var</span> layer = stack[idx++];\r\n    <span class=\"hljs-comment\">//如果没有了就退出</span>\r\n    <span class=\"hljs-keyword\">if</span>(!layer) {\r\n    <span class=\"hljs-keyword\">return</span> done();\r\n    }\r\n    <span class=\"hljs-comment\">//匹配完成后就进行</span>\r\n    self.match_layer(layer,req,res,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(err,path)</span> {</span>\r\n    <span class=\"hljs-keyword\">if</span>(err || path === <span class=\"hljs-literal\">undefined</span>){\r\n    <span class=\"hljs-keyword\">return</span> next(layerError || err);\r\n    }\r\n    layer.handle_request(req, res, next);\r\n    });\r\n    }\r\n    }</code></pre>\r\n\r\n    <p>这是最核心的方法，有请求到来之后触发这个函数，内部实现顺序匹配的方式就是使用next递归函数，每次调用next之后都会取出下一个layer出来处理，所以可以把next放到我们的处理函数中，在每一个路由处理节点上就可以决定是否要调用next。（为啥要递归+_+）</p>\r\n\r\n    <p>还有一个细节，use方法和METHOD（eg:get post head），all,还是有点区别的，use只是匹配前缀就行，而METHOD和all是要保证路径全匹配的。 <br>\r\n        所以，对于use来说，路径’/’就表示可以匹配任何路径（因为所有路径的前缀都会是’/’），这就意味着我们可以使用use来对请求进行预处理，例如cookie，session的解析</p>\r\n\r\n    <p>例如</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \">app.use(<span class=\"hljs-string\">'/user'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(req,res,next)</span>{</span>\r\n    <span class=\"hljs-comment\">//能匹配到/user或/user/info</span>\r\n    })\r\n\r\n    app.all(<span class=\"hljs-string\">'/user'</span>,<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(req,res,next)</span>{</span>\r\n    <span class=\"hljs-comment\">//只能匹配/user</span>\r\n    <span class=\"hljs-comment\">//不能匹配/user/info</span>\r\n    })</code></pre>\r\n\r\n    <p>而METHOD的实现和all一样，只不过它还限制了请求类型.</p>\r\n\r\n    <p>其实all和METHOD不是简单的使用layer匹配，还使用了route(注意和router不一样), route和之前的router类似，不过route内部只进行请求方法的判断，不判断路径，METHOD方法会先在router的layer匹配完路径之后再到layer.route中匹配请求方法. <br>\r\n        流程图如下</p>\r\n\r\n    <p><img src=\"" + __webpack_require__(!(function webpackMissingModule() { var e = new Error("Cannot find module \"./ww\""); e.code = 'MODULE_NOT_FOUND'; throw e; }())) + "\" alt=\"enter image description here\" title=\"\"></p>\r\n\r\n    <p>代码如下 <br>\r\n        router中的methods</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \">proto.route = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(path)</span>{</span>\r\n    <span class=\"hljs-keyword\">var</span> route = <span class=\"hljs-keyword\">new</span> Route(path);\r\n\r\n    <span class=\"hljs-keyword\">var</span> layer = <span class=\"hljs-keyword\">new</span> Layer(path, {\r\n    sensitive: <span class=\"hljs-keyword\">this</span>.caseSensitive,\r\n    strict: <span class=\"hljs-keyword\">this</span>.strict,\r\n    end: <span class=\"hljs-literal\">true</span>   <span class=\"hljs-comment\">//不同于router里的，这里是true，表示全匹配</span>\r\n    }, route.dispatch.bind(route));\r\n\r\n    layer.route = route;\r\n\r\n    <span class=\"hljs-keyword\">this</span>.stack.push(layer);\r\n    <span class=\"hljs-keyword\">return</span> route;\r\n    };\r\n    <span class=\"hljs-comment\">// create Router#VERB functions</span>\r\n    methods.concat(<span class=\"hljs-string\">'all'</span>).forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(method)</span>{</span>\r\n    proto[method] = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(path)</span>{</span>\r\n    <span class=\"hljs-keyword\">var</span> route = <span class=\"hljs-keyword\">this</span>.route(path)\r\n    route[method].apply(route , slice.call(<span class=\"hljs-built_in\">arguments</span>, <span class=\"hljs-number\">1</span>));\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>;\r\n    };\r\n    });</code></pre>\r\n\r\n    <p>//route中的method</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \">methods.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(method)</span>{</span>\r\n    Route.prototype[method]=<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">()</span> {</span>\r\n    <span class=\"hljs-keyword\">var</span> self = <span class=\"hljs-keyword\">this</span>;\r\n    <span class=\"hljs-keyword\">var</span> callbacks = flatten(<span class=\"hljs-built_in\">arguments</span>);\r\n    callbacks.forEach(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(fn)</span>{</span>\r\n    layer = <span class=\"hljs-keyword\">new</span> Layer(<span class=\"hljs-string\">'/'</span>,fn);\r\n    layer.method = method;\r\n    self.methods[method] = <span class=\"hljs-literal\">true</span>;\r\n    self.stack.push(layer);\r\n    });\r\n\r\n    }\r\n    })</code></pre>\r\n\r\n    <p>所以每次调用完一个METHOD之后，都会直接创建一个route，放入layer中，并把layer投放进当前app的_router中，如果在路径被匹配成功，就会进入layer.route的路由，进行请求类型匹配。</p>\r\n\r\n    <hr>\r\n\r\n\r\n\r\n    <h4 id=\"二-给reqres添加新方法\">二.  给req，res添加新方法</h4>\r\n\r\n    <p>req和res都是http模块中的野生类，所以如果要添加新的方法，最好的形式莫过于继承。 <br>\r\n        Express中就是把对req，res添加继承的函数作为一个中间件用use放进去，所以每一个请求到来之后首先都会走到里面</p>\r\n\r\n\r\n\r\n<pre class=\"prettyprint\"><code class=\"language-javascript hljs \">exports.init = <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span><span class=\"hljs-params\">(app)</span>{</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-title\">expressInit</span><span class=\"hljs-params\">(req, res, next)</span>{</span>\r\n    req.res = res;\r\n    res.req = req;\r\n    req.next = next;\r\n\r\n    req.__proto__ = app.request;\r\n    res.__proto__ = app.response;\r\n\r\n    next();\r\n    };\r\n    };</code></pre>\r\n\r\n    <p>//添加中间件</p>\r\n\r\n\r\n\r\n    <pre class=\"prettyprint\"><code class=\"language-javascript hljs \"><span class=\"hljs-keyword\">this</span>._router.use(middleware.init(<span class=\"hljs-keyword\">this</span>));</code></pre>\r\n\r\n\r\n\r\n    <h4 id=\"三-总结\">三.  总结</h4>\r\n\r\n    <p>Express的确是当前node最火的框架，社区也提供了很多现成的中间键，但个人觉得express还是有不少优化空间的，比如说路径匹配的方式，是否就一定得循环遍历(o(n))？可否用map映射(o(log n))？next的递归是否会造成node内存紧张？</p>\r\n\r\n    <p>但至少，express开创了一个足够高的起步，以至于现在都没有出现具备颠覆性的对手</p></div>";

/***/ },

/***/ 365:
/***/ function(module, exports) {

	module.exports = "<h2>全局css的尽头</h2>\r\n<p>Css选择器都存在于同一个全局环境中</p>\r\n<p>任何有年头的css使用者都不得不忍受它极具侵略性的全局特性，这是一个在documents的年代就诞生的模型，而我们现在却努力地为现代的web应用提供一个更加温顺的工作环境</p>\r\n<p>每一个选择器都有可能产生意料之外的影响，因为每一个选择器都有可能选择了其它元素或和其它选择器冲突。更有甚者，我们的选择器可能会在全局作用域生死决斗中被干掉，最终产生一点或根本对页面没有产生影响。</p>\r\n    <p>我们每次修改css文件的时候，都要小心谨慎地考虑样式所在的全局环境，并没有其它前端技术仅仅是为了这一丁点的代码可维护性，而去遵守这么多的规则。</p>\r\n    <p>然而我们并不需要这样</p>\r\n    <p>是时候干掉全局样式了</p>\r\n    <blockquote>\r\n        <p>在其它语言，有时稍微改改全局变量时可以接受的，如果有过的话~</p>\r\n    </blockquote>\r\n    <p>在JavaScript社区，幸亏有像Browserify，webpack和JSPM之类的框架，我们可以让我们的代码包含很多小模块，每一个模块分装好各自的依赖项，只暴露出最少的API</p>\r\n    <p>然而，CSS却可以随时作用于任何模块</p>\r\n    <p>很多人，也包括我自己，到目前为止已经使用CSS太久了，以致我们没有觉得局部作用域的缺失是一个可以不需要浏览器厂商放大招就可以解决的问题。即使这样，我们仍需要去等待大部分用户都使用支持影子树(目前只有高版本chrome支持)的浏览器</p>\r\n    <p>我们至今都使用着，像OOCSS,SMACC,BEM和SUIT之类的命名规则和全局CSS的问题作斗争，它们提供为了我们提供了避免命名冲突和模拟正常命名空间规则的方法。</p>\r\n    <p>不可否认的是，在改良CSS的道路还很遥远，并没有什么方法能够真正解决样式表的问题，不管我们选择哪一种约定，我们都会被全局选择器卡住。</p>\r\n    <p>但在2015年4月22日，一切都变了</p>\r\n    <p>正如我们前一篇文章——“Block，Element，Modifying Your JavaScript  Components”所说的——我们能够利用Webpack在js模块中引入CSS文件。如果你对此不太熟悉，可以看看这篇文章，以免漏掉重要的内容</p>\r\n    <p>用Webpack的css-loader引入组件的CSS代码如下</p>\r\n<pre><code>require('./MyComponent.css');\r\n</code></pre>\r\n\r\n    <p>第一眼看，甚至以为我们引入的不是CSS而是JS，这的确很奇怪</p>\r\n    <p>一般来说，调用一个require应该给局部的作用域引入东西，如果没有，正如前面影响全局全局作用域所介绍的，这是一个二流设计的表现</p>\r\n    <p>但这是CSS，影响全局作用域是必要的恶行</p>\r\n    <p>我们也许会这么认为</p>\r\n    <p>在2015年4月22号，Tobias Kopper，这位Webpack的作者提交了css-loader新特性的第一个迭代版本，那时被叫做placeholders，也就是局部作用域。\t</p>\r\n    <p>这个特性允许我们从CSS文件输出类名输出到JavaScript代码中</p>\r\n    <p>总之，原来的写法：</p>\r\n<pre><code>require('./MyComponent.css');\r\n</code></pre>\r\n\r\n    <p>现在：</p>\r\n<pre><code>import styles from './MyComponent.css';\r\n</code></pre>\r\n\r\n    <p>所以，在这个例子中，样式被编译为什么？</p>\r\n    <p>注意从CSS中到底有什么被导出，我们看一下样式表大致的形式是：</p>\r\n<pre><code>:local(.foo) {\r\n    color: red;\r\n}\r\n:local(.bar) {\r\n    color: blue;\r\n}\r\n</code></pre>\r\n\r\n    <p>在这个例子里面，我们使用css-loader的定义：loacl(.identifier)语法来输出两个标识符——foo和bar</p>\r\n    <p>这些标识符映射着我们在JavaScript文件中用到的类名，例如在使用React时：</p>\r\n<pre><code>import styles from './MyComponent.css';\r\n    import React, { Component } from 'react';\r\n    export default class MyComponent extends Component {\r\n        render() {\r\n        return (\r\n        &lt;div&gt;\r\n        &lt;div className={styles.foo}&gt;Foo&lt;/div&gt;\r\n        &lt;div className={styles.bar}&gt;Bar&lt;/div&gt;\r\n        &lt;/div&gt;\r\n        );\r\n    }\r\n}\r\n</code></pre>\r\n\r\n    <p>重要的是，这些标识符映射的类名在全局作用域中一定是独一无二的。</p>\r\n    <p>我们再也不需要给所有选择器添加冗长的前缀去模拟作用域了。更多的组件定义他们自己的foo和bar标识符了，不像传统的全局选择器模型，无法减少命名冲突</p>\r\n    <p>了解这其中发生的巨大变化非常重要</p>\r\n    <p>我们现在能够大胆地改变我们的CSS代码，而不用担心无意间影响到页面上的其它元素，我们为CSS引用了一种更为健全的的作用域模型</p>\r\n    <p>全局CSS的好处就是样式在于，不同组件间能通过通用类名的实现可重用性，然而这在新模型中也可以实现，关键的区别在于，就像我们使用别的技术，我们需要明确地引入依赖的类，我们的代码不能够有很多关于全局环境的设想.</p>\r\n    <blockquote>\r\n        <p>现在我们鼓励编写可维护的CSS代码，但不是通过对命名规范的坚守，而是在开发过程中封装样式。</p>\r\n    </blockquote>\r\n    <p>作为使用了这种作用域的代价，我们把对类名的实际控制交给了给了Webpack</p>\r\n    <p>css-loader会默认把我们的标识符转化为哈希值</p>\r\n    <p>例如：</p>\r\n<pre><code>:local(.foo) { … }\r\n</code></pre>\r\n\r\n    <p>被编译为：</p>\r\n<pre><code>._1rJwx92-gmbvaLiDdzgXiJ { … }\r\n</code></pre>\r\n\r\n    <p>在开发中，这对调式来说并不是特别有帮助，为了让类名更加好用，我们可以在Webpack的配置文件中配置类名的格式，并作为一个参数传给css-loader：</p>\r\n<pre><code>loaders: [\r\n    ...\r\n    {\r\n        test: /\\.css$/,\r\n        loader: 'css?localIdentName=[name]__[local]___[hash:base64:5]'\r\n    }\r\n]\r\n</code></pre>\r\n\r\n    <p>这样一来，我们foo标识符会从原先被编译为这样：</p>\r\n<pre><code>.MyComponent__foo___1rJwx { … }\r\n</code></pre>\r\n\r\n    <p>我们现在就能清晰地看出标识符的名称，还有组件的归属</p>\r\n    <p>通过使用node_nev环境变量，我们能够为开发和生产环境配置不同的类名</p>\r\n<pre><code>loader: 'css?localIdentName=' + (\r\n    process.env.NODE_ENV === 'development' ?\r\n    '[name]__[local]___[hash:base64:5]' :\r\n    '[hash:base64:5]'\r\n)\r\n</code></pre>\r\n\r\n    <blockquote>\r\n        <p>既然Webpack已经控制了我们的类名，那我们就能在线上环境中支持压缩类名。</p>\r\n    </blockquote>\r\n    <p>当我们一发现这些特性，我们会毫不犹豫地在最近的项目中本地化我们的样式，而如果我们已经在每一个组件中使用BEM本地化我们的CSS，只要按照规范，这会是一个自然而然的过程</p>\r\n    <p>有趣的是，一个模式就这样快速地产生了，我们大多数的CSS文件只会包含了本地的标识符</p>\r\n<pre><code>:local(.backdrop) { … }\r\n:local(.root_isCollapsed .backdrop) { … }\r\n:local(.field) { … }\r\n:local(.field):focus { … }\r\netc…\r\n</code></pre>\r\n\r\n    <p>全局选择器只有在应用中的少数地方被用到，这自然而然地引向了一个问题。</p>\r\n    <blockquote>\r\n        <p>如果替代掉那之前的local语法，我们的选择默认就是本地的，而全局选择器只是一个可选项\r\n            如果我们改了之后会怎样？</p>\r\n    </blockquote>\r\n<pre><code>.backdrop { … }\r\n.root_isCollapsed .backdrop { … }\r\n.field { … }\r\n.field:focus { … }\r\n</code></pre>\r\n\r\n    <p>因为这些选择会自然地变得太模糊，把它们转化为css-loader的本地作用域格式会消除这些问题，并且保证它们只会在被使用到的模块中</p>\r\n    <p>当不得不使用全局样式时，我们能够明确地使用全局语法做记号</p>\r\n    <p>例如，当使用ReactCSSTransitionGroup生成的非局部样式类时</p>\r\n<pre><code>.panel :global .transition-active-enter { … }\r\n</code></pre>\r\n\r\n    <p>在这里我们不仅用了本地作用域的panel标识符，还使用了在我们控制之外的全局的类名。</p>\r\n    <p>一旦我们开始研究如何使用默认本地的语法，我们会意识到这并不会太难。</p>\r\n    <p>为了这个目的，我们可以利用PostCSS，一个可以让我们编写CSS转换插件的神奇的工具，其中最有名的CSS构建工具是Autoprfixer，实际上是PostCSS的插件，同时也是一个独立的工具。</p>\r\n    <p>令人兴奋的是，介绍局部作用的CSS只是一个开始。</p>\r\n    <p>让构建工具处理类名的生成有很多潜在的巨大影响，从长远看，我们会不再做人肉编译器，而是让直接电脑最优化输出。</p>\r\n    <blockquote>\r\n        <p>未来，我们可以自动生成在不同的组件间共享的类，在编译阶段就根据样式的可重用性执行最优方案。</p>\r\n    </blockquote>\r\n    <p>一旦你使用过局部CSS，就真的回不了头。在样式表中体验真正的局部作用域，并且兼容所有浏览器，真是一件不可轻视的事。</p>\r\n    <p>提出局部作用域对我们怎样处理CSS有着重大的连锁反应。命名规则，可重用模式，把样式取出放进单独的包中都深受这变化的直接影响。当然，我们只是站在局部CSS的这一新领域的山脚下</p>\r\n    <p>我们现在仍着力于梳理这一转变的分支。通过大家有意义的输入和试验，我希望这是一个能让我们在一起组成一个更大的社区的对话。</p>\r\n    <hr />\r\n    <p>附上英文地址：<a href=\"https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284\">https://medium.com/seek-ui-engineering/the-end-of-global-css-90d2a4a06284</a></p>\r\n    <p>css-Load的地址：<a href=\"https://github.com/webpack/css-loader\">https://github.com/webpack/css-loader</a></p>\r\n";

/***/ }

});